import * as tslib_1 from "tslib";
import { Directive, forwardRef, Input } from "@angular/core";
import { NG_VALIDATORS } from "@angular/forms";
import { UniversalValidators } from "./universal-validators";
var WhiteSpaceValidatorDirective = /** @class */ (function () {
    function WhiteSpaceValidatorDirective() {
    }
    WhiteSpaceValidatorDirective_1 = WhiteSpaceValidatorDirective;
    WhiteSpaceValidatorDirective.prototype.ngOnInit = function () {
        this.validator = UniversalValidators.noWhitespace;
    };
    WhiteSpaceValidatorDirective.prototype.validate = function (c) {
        return this.validator(c);
    };
    var WhiteSpaceValidatorDirective_1;
    WhiteSpaceValidatorDirective = WhiteSpaceValidatorDirective_1 = tslib_1.__decorate([
        Directive({
            selector: "[noWhitespace][formControlName],[noWhitespace][formControl],[noWhitespace][ngModel]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return WhiteSpaceValidatorDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], WhiteSpaceValidatorDirective);
    return WhiteSpaceValidatorDirective;
}());
export { WhiteSpaceValidatorDirective };
var EmptyStringValidatorDirective = /** @class */ (function () {
    function EmptyStringValidatorDirective() {
    }
    EmptyStringValidatorDirective_1 = EmptyStringValidatorDirective;
    EmptyStringValidatorDirective.prototype.ngOnInit = function () {
        this.validator = UniversalValidators.noEmptyString;
    };
    EmptyStringValidatorDirective.prototype.validate = function (c) {
        return this.validator(c);
    };
    var EmptyStringValidatorDirective_1;
    EmptyStringValidatorDirective = EmptyStringValidatorDirective_1 = tslib_1.__decorate([
        Directive({
            selector: "[noEmptyString][formControlName],[noEmptyString][formControl],[noEmptyString][ngModel]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return EmptyStringValidatorDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], EmptyStringValidatorDirective);
    return EmptyStringValidatorDirective;
}());
export { EmptyStringValidatorDirective };
var IsNumberValidatorDirective = /** @class */ (function () {
    function IsNumberValidatorDirective() {
    }
    IsNumberValidatorDirective_1 = IsNumberValidatorDirective;
    IsNumberValidatorDirective.prototype.ngOnInit = function () {
        this.validator = UniversalValidators.isNumber;
    };
    IsNumberValidatorDirective.prototype.validate = function (c) {
        return this.validator(c);
    };
    var IsNumberValidatorDirective_1;
    IsNumberValidatorDirective = IsNumberValidatorDirective_1 = tslib_1.__decorate([
        Directive({
            selector: "[isNumber][formControlName],[isNumber][formControl],[isNumber][ngModel]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return IsNumberValidatorDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], IsNumberValidatorDirective);
    return IsNumberValidatorDirective;
}());
export { IsNumberValidatorDirective };
var IsInRangeValidatorDirective = /** @class */ (function () {
    function IsInRangeValidatorDirective() {
    }
    IsInRangeValidatorDirective_1 = IsInRangeValidatorDirective;
    IsInRangeValidatorDirective.prototype.ngOnInit = function () {
        this.validator = UniversalValidators.isInRange(this.minValue, this.maxValue);
    };
    IsInRangeValidatorDirective.prototype.ngOnChanges = function (changes) {
        var minValue = this.minValue;
        var maxValue = this.maxValue;
        var changed = false;
        if (changes.minValue) {
            minValue = changes.minValue.currentValue;
            changed = changes.minValue.isFirstChange() ? false : true;
        }
        if (changes.maxValue) {
            maxValue = changes.maxValue.currentValue;
            changed = changes.maxValue.isFirstChange() ? false : true;
        }
        if (changed) {
            this.validator = UniversalValidators.isInRange(minValue, maxValue);
            this.onChange();
        }
    };
    IsInRangeValidatorDirective.prototype.validate = function (c) {
        return this.validator(c);
    };
    IsInRangeValidatorDirective.prototype.registerOnValidatorChange = function (fn) {
        this.onChange = fn;
    };
    var IsInRangeValidatorDirective_1;
    tslib_1.__decorate([
        Input()
    ], IsInRangeValidatorDirective.prototype, "minValue", void 0);
    tslib_1.__decorate([
        Input()
    ], IsInRangeValidatorDirective.prototype, "maxValue", void 0);
    IsInRangeValidatorDirective = IsInRangeValidatorDirective_1 = tslib_1.__decorate([
        Directive({
            selector: "[isInRange][formControlName],[isInRange][formControl],[isInRange][ngModel]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return IsInRangeValidatorDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], IsInRangeValidatorDirective);
    return IsInRangeValidatorDirective;
}());
export { IsInRangeValidatorDirective };
var MaxValidatorDirective = /** @class */ (function () {
    function MaxValidatorDirective() {
    }
    MaxValidatorDirective_1 = MaxValidatorDirective;
    MaxValidatorDirective.prototype.ngOnInit = function () {
        this.validator = UniversalValidators.max(this.max);
    };
    MaxValidatorDirective.prototype.ngOnChanges = function (changes) {
        if (changes.max && !changes.max.isFirstChange()) {
            this.validator = UniversalValidators.max(changes.max.currentValue);
            this.onChange();
        }
    };
    MaxValidatorDirective.prototype.validate = function (c) {
        return this.validator(c);
    };
    MaxValidatorDirective.prototype.registerOnValidatorChange = function (fn) {
        this.onChange = fn;
    };
    var MaxValidatorDirective_1;
    tslib_1.__decorate([
        Input()
    ], MaxValidatorDirective.prototype, "max", void 0);
    MaxValidatorDirective = MaxValidatorDirective_1 = tslib_1.__decorate([
        Directive({
            selector: "input[type=text][max][formControlName],input[type=text][max][formControl],input[type=text][max][ngModel]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return MaxValidatorDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], MaxValidatorDirective);
    return MaxValidatorDirective;
}());
export { MaxValidatorDirective };
var MinValidatorDirective = /** @class */ (function () {
    function MinValidatorDirective() {
    }
    MinValidatorDirective_1 = MinValidatorDirective;
    MinValidatorDirective.prototype.ngOnInit = function () {
        this.validator = UniversalValidators.min(this.min);
    };
    MinValidatorDirective.prototype.ngOnChanges = function (changes) {
        if (changes.min && !changes.min.isFirstChange()) {
            this.validator = UniversalValidators.min(changes.min.currentValue);
            this.onChange();
        }
    };
    MinValidatorDirective.prototype.validate = function (c) {
        return this.validator(c);
    };
    MinValidatorDirective.prototype.registerOnValidatorChange = function (fn) {
        this.onChange = fn;
    };
    var MinValidatorDirective_1;
    tslib_1.__decorate([
        Input()
    ], MinValidatorDirective.prototype, "min", void 0);
    MinValidatorDirective = MinValidatorDirective_1 = tslib_1.__decorate([
        Directive({
            selector: "input[type=text][min][formControlName],input[type=text][min][formControl],input[type=text][min][ngModel]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return MinValidatorDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], MinValidatorDirective);
    return MinValidatorDirective;
}());
export { MinValidatorDirective };
var MinDateValidatorDirective = /** @class */ (function () {
    function MinDateValidatorDirective() {
    }
    MinDateValidatorDirective_1 = MinDateValidatorDirective;
    MinDateValidatorDirective.prototype.ngOnInit = function () {
        this.validator = UniversalValidators.minDate(new Date(this.minDate));
    };
    MinDateValidatorDirective.prototype.ngOnChanges = function (changes) {
        if (changes.minDate && !changes.minDate.isFirstChange()) {
            this.validator = UniversalValidators.minDate(changes.min.currentValue);
            this.onChange();
        }
    };
    MinDateValidatorDirective.prototype.validate = function (c) {
        return this.validator(c);
    };
    MinDateValidatorDirective.prototype.registerOnValidatorChange = function (fn) {
        this.onChange = fn;
    };
    var MinDateValidatorDirective_1;
    tslib_1.__decorate([
        Input()
    ], MinDateValidatorDirective.prototype, "minDate", void 0);
    MinDateValidatorDirective = MinDateValidatorDirective_1 = tslib_1.__decorate([
        Directive({
            selector: "input[type=text][minDate][formControlName],input[type=text][minDate][formControl],input[type=text][minDate][ngModel]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return MinDateValidatorDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], MinDateValidatorDirective);
    return MinDateValidatorDirective;
}());
export { MinDateValidatorDirective };
var MaxDateValidatorDirective = /** @class */ (function () {
    function MaxDateValidatorDirective() {
    }
    MaxDateValidatorDirective_1 = MaxDateValidatorDirective;
    MaxDateValidatorDirective.prototype.ngOnInit = function () {
        this.validator = UniversalValidators.maxDate(new Date(this.maxDate));
    };
    MaxDateValidatorDirective.prototype.ngOnChanges = function (changes) {
        if (changes.maxDate && !changes.maxDate.isFirstChange()) {
            this.validator = UniversalValidators.maxDate(changes.min.currentValue);
            this.onChange();
        }
    };
    MaxDateValidatorDirective.prototype.validate = function (c) {
        return this.validator(c);
    };
    MaxDateValidatorDirective.prototype.registerOnValidatorChange = function (fn) {
        this.onChange = fn;
    };
    var MaxDateValidatorDirective_1;
    tslib_1.__decorate([
        Input()
    ], MaxDateValidatorDirective.prototype, "maxDate", void 0);
    MaxDateValidatorDirective = MaxDateValidatorDirective_1 = tslib_1.__decorate([
        Directive({
            selector: "input[type=text][maxDate][formControlName],input[type=text][maxDate][formControl],input[type=text][maxDate][ngModel]",
            providers: [
                {
                    provide: NG_VALIDATORS,
                    // tslint:disable-next-line:no-forward-ref
                    useExisting: forwardRef(function () { return MaxDateValidatorDirective_1; }),
                    multi: true,
                },
            ],
        })
    ], MaxDateValidatorDirective);
    return MaxDateValidatorDirective;
}());
export { MaxDateValidatorDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW5pdmVyc2FsLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC12YWxpZGF0b3JzLyIsInNvdXJjZXMiOlsiY29tcG9uZW50cy91bml2ZXJzYWwvdW5pdmVyc2FsLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFvQyxNQUFNLGVBQWUsQ0FBQztBQUMvRixPQUFPLEVBQW1CLGFBQWEsRUFBNEMsTUFBTSxnQkFBZ0IsQ0FBQztBQUUxRyxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQWE3RDtJQUFBO0lBVUEsQ0FBQztxQ0FWWSw0QkFBNEI7SUFHdkMsK0NBQVEsR0FBUjtRQUNFLElBQUksQ0FBQyxTQUFTLEdBQUcsbUJBQW1CLENBQUMsWUFBWSxDQUFDO0lBQ3BELENBQUM7SUFFRCwrQ0FBUSxHQUFSLFVBQVMsQ0FBa0I7UUFDekIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNCLENBQUM7O0lBVFUsNEJBQTRCO1FBWHhDLFNBQVMsQ0FBQztZQUNULFFBQVEsRUFBRSxxRkFBcUY7WUFDL0YsU0FBUyxFQUFFO2dCQUNUO29CQUNFLE9BQU8sRUFBRSxhQUFhO29CQUN0QiwwQ0FBMEM7b0JBQzFDLFdBQVcsRUFBRSxVQUFVLENBQUMsY0FBTSxPQUFBLDhCQUE0QixFQUE1QixDQUE0QixDQUFDO29CQUMzRCxLQUFLLEVBQUUsSUFBSTtpQkFDWjthQUNGO1NBQ0YsQ0FBQztPQUNXLDRCQUE0QixDQVV4QztJQUFELG1DQUFDO0NBQUEsQUFWRCxJQVVDO1NBVlksNEJBQTRCO0FBdUJ6QztJQUFBO0lBVUEsQ0FBQztzQ0FWWSw2QkFBNkI7SUFHeEMsZ0RBQVEsR0FBUjtRQUNFLElBQUksQ0FBQyxTQUFTLEdBQUcsbUJBQW1CLENBQUMsYUFBYSxDQUFDO0lBQ3JELENBQUM7SUFFRCxnREFBUSxHQUFS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LHlCQUF5QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgZm9yd2FyZFJlZiwgSW5wdXQsIE9uSW5pdCwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgTkdfVkFMSURBVE9SUywgVmFsaWRhdG9yLCBWYWxpZGF0b3JGbiwgVmFsaWRhdGlvbkVycm9ycyB9IGZyb20gXCJAYW5ndWxhci9mb3Jtc1wiO1xuXG5pbXBvcnQgeyBVbml2ZXJzYWxWYWxpZGF0b3JzIH0gZnJvbSBcIi4vdW5pdmVyc2FsLXZhbGlkYXRvcnNcIjtcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiBcIltub1doaXRlc3BhY2VdW2Zvcm1Db250cm9sTmFtZV0sW25vV2hpdGVzcGFjZV1bZm9ybUNvbnRyb2xdLFtub1doaXRlc3BhY2VdW25nTW9kZWxdXCIsXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFdoaXRlU3BhY2VWYWxpZGF0b3JEaXJlY3RpdmUpLFxuICAgICAgbXVsdGk6IHRydWUsXG4gICAgfSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgV2hpdGVTcGFjZVZhbGlkYXRvckRpcmVjdGl2ZSBpbXBsZW1lbnRzIFZhbGlkYXRvciwgT25Jbml0IHtcbiAgcHJpdmF0ZSB2YWxpZGF0b3I6IFZhbGlkYXRvckZuO1xuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMudmFsaWRhdG9yID0gVW5pdmVyc2FsVmFsaWRhdG9ycy5ub1doaXRlc3BhY2U7XG4gIH1cblxuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0b3IoYyk7XG4gIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiBcIltub0VtcHR5U3RyaW5nXVtmb3JtQ29udHJvbE5hbWVdLFtub0VtcHR5U3RyaW5nXVtmb3JtQ29udHJvbF0sW25vRW1wdHlTdHJpbmddW25nTW9kZWxdXCIsXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEVtcHR5U3RyaW5nVmFsaWRhdG9yRGlyZWN0aXZlKSxcbiAgICAgIG11bHRpOiB0cnVlLFxuICAgIH0sXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIEVtcHR5U3RyaW5nVmFsaWRhdG9yRGlyZWN0aXZlIGltcGxlbWVudHMgVmFsaWRhdG9yLCBPbkluaXQge1xuICBwcml2YXRlIHZhbGlkYXRvcjogVmFsaWRhdG9yRm47XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy52YWxpZGF0b3IgPSBVbml2ZXJzYWxWYWxpZGF0b3JzLm5vRW1wdHlTdHJpbmc7XG4gIH1cblxuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0b3IoYyk7XG4gIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiBcIltpc051bWJlcl1bZm9ybUNvbnRyb2xOYW1lXSxbaXNOdW1iZXJdW2Zvcm1Db250cm9sXSxbaXNOdW1iZXJdW25nTW9kZWxdXCIsXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IElzTnVtYmVyVmFsaWRhdG9yRGlyZWN0aXZlKSxcbiAgICAgIG11bHRpOiB0cnVlLFxuICAgIH0sXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIElzTnVtYmVyVmFsaWRhdG9yRGlyZWN0aXZlIGltcGxlbWVudHMgVmFsaWRhdG9yLCBPbkluaXQge1xuICBwcml2YXRlIHZhbGlkYXRvcjogVmFsaWRhdG9yRm47XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy52YWxpZGF0b3IgPSBVbml2ZXJzYWxWYWxpZGF0b3JzLmlzTnVtYmVyO1xuICB9XG5cbiAgdmFsaWRhdGUoYzogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yKGMpO1xuICB9XG59XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogXCJbaXNJblJhbmdlXVtmb3JtQ29udHJvbE5hbWVdLFtpc0luUmFuZ2VdW2Zvcm1Db250cm9sXSxbaXNJblJhbmdlXVtuZ01vZGVsXVwiLFxuICBwcm92aWRlcnM6IFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBJc0luUmFuZ2VWYWxpZGF0b3JEaXJlY3RpdmUpLFxuICAgICAgbXVsdGk6IHRydWUsXG4gICAgfSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgSXNJblJhbmdlVmFsaWRhdG9yRGlyZWN0aXZlIGltcGxlbWVudHMgVmFsaWRhdG9yLCBPbkluaXQsIE9uQ2hhbmdlcyB7XG4gIEBJbnB1dCgpIG1pblZhbHVlOiBudW1iZXI7XG4gIEBJbnB1dCgpIG1heFZhbHVlOiBudW1iZXI7XG5cbiAgcHJpdmF0ZSB2YWxpZGF0b3I6IFZhbGlkYXRvckZuO1xuICBwcml2YXRlIG9uQ2hhbmdlOiAoKSA9PiB2b2lkO1xuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMudmFsaWRhdG9yID0gVW5pdmVyc2FsVmFsaWRhdG9ycy5pc0luUmFuZ2UodGhpcy5taW5WYWx1ZSwgdGhpcy5tYXhWYWx1ZSk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgbGV0IG1pblZhbHVlID0gdGhpcy5taW5WYWx1ZTtcbiAgICBsZXQgbWF4VmFsdWUgPSB0aGlzLm1heFZhbHVlO1xuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICBpZiAoY2hhbmdlcy5taW5WYWx1ZSkge1xuICAgICAgbWluVmFsdWUgPSBjaGFuZ2VzLm1pblZhbHVlLmN1cnJlbnRWYWx1ZTtcbiAgICAgIGNoYW5nZWQgPSBjaGFuZ2VzLm1pblZhbHVlLmlzRmlyc3RDaGFuZ2UoKSA/IGZhbHNlIDogdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoY2hhbmdlcy5tYXhWYWx1ZSkge1xuICAgICAgbWF4VmFsdWUgPSBjaGFuZ2VzLm1heFZhbHVlLmN1cnJlbnRWYWx1ZTtcbiAgICAgIGNoYW5nZWQgPSBjaGFuZ2VzLm1heFZhbHVlLmlzRmlyc3RDaGFuZ2UoKSA/IGZhbHNlIDogdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy52YWxpZGF0b3IgPSBVbml2ZXJzYWxWYWxpZGF0b3JzLmlzSW5SYW5nZShtaW5WYWx1ZSwgbWF4VmFsdWUpO1xuICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlKGM6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRvcihjKTtcbiAgfVxuXG4gIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiBcImlucHV0W3R5cGU9dGV4dF1bbWF4XVtmb3JtQ29udHJvbE5hbWVdLGlucHV0W3R5cGU9dGV4dF1bbWF4XVtmb3JtQ29udHJvbF0saW5wdXRbdHlwZT10ZXh0XVttYXhdW25nTW9kZWxdXCIsXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE1heFZhbGlkYXRvckRpcmVjdGl2ZSksXG4gICAgICBtdWx0aTogdHJ1ZSxcbiAgICB9LFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBNYXhWYWxpZGF0b3JEaXJlY3RpdmUgaW1wbGVtZW50cyBWYWxpZGF0b3IsIE9uSW5pdCwgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgbWF4OiBudW1iZXI7XG5cbiAgcHJpdmF0ZSB2YWxpZGF0b3I6IFZhbGlkYXRvckZuO1xuICBwcml2YXRlIG9uQ2hhbmdlOiAoKSA9PiB2b2lkO1xuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMudmFsaWRhdG9yID0gVW5pdmVyc2FsVmFsaWRhdG9ycy5tYXgodGhpcy5tYXgpO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIGlmIChjaGFuZ2VzLm1heCAmJiAhY2hhbmdlcy5tYXguaXNGaXJzdENoYW5nZSgpKSB7XG4gICAgICB0aGlzLnZhbGlkYXRvciA9IFVuaXZlcnNhbFZhbGlkYXRvcnMubWF4KGNoYW5nZXMubWF4LmN1cnJlbnRWYWx1ZSk7XG4gICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUoYzogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yKGMpO1xuICB9XG5cbiAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6IFwiaW5wdXRbdHlwZT10ZXh0XVttaW5dW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT10ZXh0XVttaW5dW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPXRleHRdW21pbl1bbmdNb2RlbF1cIixcbiAgcHJvdmlkZXJzOiBbXG4gICAge1xuICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTWluVmFsaWRhdG9yRGlyZWN0aXZlKSxcbiAgICAgIG11bHRpOiB0cnVlLFxuICAgIH0sXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIE1pblZhbGlkYXRvckRpcmVjdGl2ZSBpbXBsZW1lbnRzIFZhbGlkYXRvciwgT25Jbml0LCBPbkNoYW5nZXMge1xuICBASW5wdXQoKSBtaW46IG51bWJlcjtcblxuICBwcml2YXRlIHZhbGlkYXRvcjogVmFsaWRhdG9yRm47XG4gIHByaXZhdGUgb25DaGFuZ2U6ICgpID0+IHZvaWQ7XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy52YWxpZGF0b3IgPSBVbml2ZXJzYWxWYWxpZGF0b3JzLm1pbih0aGlzLm1pbik7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgaWYgKGNoYW5nZXMubWluICYmICFjaGFuZ2VzLm1pbi5pc0ZpcnN0Q2hhbmdlKCkpIHtcbiAgICAgIHRoaXMudmFsaWRhdG9yID0gVW5pdmVyc2FsVmFsaWRhdG9ycy5taW4oY2hhbmdlcy5taW4uY3VycmVudFZhbHVlKTtcbiAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0b3IoYyk7XG4gIH1cblxuICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICB9XG59XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogXCJpbnB1dFt0eXBlPXRleHRdW21pbkRhdGVdW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT10ZXh0XVttaW5EYXRlXVtmb3JtQ29udHJvbF0saW5wdXRbdHlwZT10ZXh0XVttaW5EYXRlXVtuZ01vZGVsXVwiLFxuICBwcm92aWRlcnM6IFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNaW5EYXRlVmFsaWRhdG9yRGlyZWN0aXZlKSxcbiAgICAgIG11bHRpOiB0cnVlLFxuICAgIH0sXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIE1pbkRhdGVWYWxpZGF0b3JEaXJlY3RpdmUgaW1wbGVtZW50cyBWYWxpZGF0b3IsIE9uSW5pdCwgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgbWluRGF0ZTogc3RyaW5nO1xuXG4gIHByaXZhdGUgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcbiAgcHJpdmF0ZSBvbkNoYW5nZTogKCkgPT4gdm9pZDtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnZhbGlkYXRvciA9IFVuaXZlcnNhbFZhbGlkYXRvcnMubWluRGF0ZShuZXcgRGF0ZSh0aGlzLm1pbkRhdGUpKTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBpZiAoY2hhbmdlcy5taW5EYXRlICYmICFjaGFuZ2VzLm1pbkRhdGUuaXNGaXJzdENoYW5nZSgpKSB7XG4gICAgICB0aGlzLnZhbGlkYXRvciA9IFVuaXZlcnNhbFZhbGlkYXRvcnMubWluRGF0ZShjaGFuZ2VzLm1pbi5jdXJyZW50VmFsdWUpO1xuICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlKGM6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRvcihjKTtcbiAgfVxuXG4gIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiBcImlucHV0W3R5cGU9dGV4dF1bbWF4RGF0ZV1bZm9ybUNvbnRyb2xOYW1lXSxpbnB1dFt0eXBlPXRleHRdW21heERhdGVdW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPXRleHRdW21heERhdGVdW25nTW9kZWxdXCIsXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE1heERhdGVWYWxpZGF0b3JEaXJlY3RpdmUpLFxuICAgICAgbXVsdGk6IHRydWUsXG4gICAgfSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgTWF4RGF0ZVZhbGlkYXRvckRpcmVjdGl2ZSBpbXBsZW1lbnRzIFZhbGlkYXRvciwgT25Jbml0LCBPbkNoYW5nZXMge1xuICBASW5wdXQoKSBtYXhEYXRlOiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSB2YWxpZGF0b3I6IFZhbGlkYXRvckZuO1xuICBwcml2YXRlIG9uQ2hhbmdlOiAoKSA9PiB2b2lkO1xuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMudmFsaWRhdG9yID0gVW5pdmVyc2FsVmFsaWRhdG9ycy5tYXhEYXRlKG5ldyBEYXRlKHRoaXMubWF4RGF0ZSkpO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIGlmIChjaGFuZ2VzLm1heERhdGUgJiYgIWNoYW5nZXMubWF4RGF0ZS5pc0ZpcnN0Q2hhbmdlKCkpIHtcbiAgICAgIHRoaXMudmFsaWRhdG9yID0gVW5pdmVyc2FsVmFsaWRhdG9ycy5tYXhEYXRlKGNoYW5nZXMubWluLmN1cnJlbnRWYWx1ZSk7XG4gICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUoYzogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yKGMpO1xuICB9XG5cbiAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgfVxufSJdfQ==