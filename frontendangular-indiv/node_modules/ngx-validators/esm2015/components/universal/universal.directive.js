var WhiteSpaceValidatorDirective_1, EmptyStringValidatorDirective_1, IsNumberValidatorDirective_1, IsInRangeValidatorDirective_1, MaxValidatorDirective_1, MinValidatorDirective_1, MinDateValidatorDirective_1, MaxDateValidatorDirective_1;
import * as tslib_1 from "tslib";
import { Directive, forwardRef, Input } from "@angular/core";
import { NG_VALIDATORS } from "@angular/forms";
import { UniversalValidators } from "./universal-validators";
let WhiteSpaceValidatorDirective = WhiteSpaceValidatorDirective_1 = class WhiteSpaceValidatorDirective {
    ngOnInit() {
        this.validator = UniversalValidators.noWhitespace;
    }
    validate(c) {
        return this.validator(c);
    }
};
WhiteSpaceValidatorDirective = WhiteSpaceValidatorDirective_1 = tslib_1.__decorate([
    Directive({
        selector: "[noWhitespace][formControlName],[noWhitespace][formControl],[noWhitespace][ngModel]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(() => WhiteSpaceValidatorDirective_1),
                multi: true,
            },
        ],
    })
], WhiteSpaceValidatorDirective);
export { WhiteSpaceValidatorDirective };
let EmptyStringValidatorDirective = EmptyStringValidatorDirective_1 = class EmptyStringValidatorDirective {
    ngOnInit() {
        this.validator = UniversalValidators.noEmptyString;
    }
    validate(c) {
        return this.validator(c);
    }
};
EmptyStringValidatorDirective = EmptyStringValidatorDirective_1 = tslib_1.__decorate([
    Directive({
        selector: "[noEmptyString][formControlName],[noEmptyString][formControl],[noEmptyString][ngModel]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(() => EmptyStringValidatorDirective_1),
                multi: true,
            },
        ],
    })
], EmptyStringValidatorDirective);
export { EmptyStringValidatorDirective };
let IsNumberValidatorDirective = IsNumberValidatorDirective_1 = class IsNumberValidatorDirective {
    ngOnInit() {
        this.validator = UniversalValidators.isNumber;
    }
    validate(c) {
        return this.validator(c);
    }
};
IsNumberValidatorDirective = IsNumberValidatorDirective_1 = tslib_1.__decorate([
    Directive({
        selector: "[isNumber][formControlName],[isNumber][formControl],[isNumber][ngModel]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(() => IsNumberValidatorDirective_1),
                multi: true,
            },
        ],
    })
], IsNumberValidatorDirective);
export { IsNumberValidatorDirective };
let IsInRangeValidatorDirective = IsInRangeValidatorDirective_1 = class IsInRangeValidatorDirective {
    ngOnInit() {
        this.validator = UniversalValidators.isInRange(this.minValue, this.maxValue);
    }
    ngOnChanges(changes) {
        let minValue = this.minValue;
        let maxValue = this.maxValue;
        let changed = false;
        if (changes.minValue) {
            minValue = changes.minValue.currentValue;
            changed = changes.minValue.isFirstChange() ? false : true;
        }
        if (changes.maxValue) {
            maxValue = changes.maxValue.currentValue;
            changed = changes.maxValue.isFirstChange() ? false : true;
        }
        if (changed) {
            this.validator = UniversalValidators.isInRange(minValue, maxValue);
            this.onChange();
        }
    }
    validate(c) {
        return this.validator(c);
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
};
tslib_1.__decorate([
    Input()
], IsInRangeValidatorDirective.prototype, "minValue", void 0);
tslib_1.__decorate([
    Input()
], IsInRangeValidatorDirective.prototype, "maxValue", void 0);
IsInRangeValidatorDirective = IsInRangeValidatorDirective_1 = tslib_1.__decorate([
    Directive({
        selector: "[isInRange][formControlName],[isInRange][formControl],[isInRange][ngModel]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(() => IsInRangeValidatorDirective_1),
                multi: true,
            },
        ],
    })
], IsInRangeValidatorDirective);
export { IsInRangeValidatorDirective };
let MaxValidatorDirective = MaxValidatorDirective_1 = class MaxValidatorDirective {
    ngOnInit() {
        this.validator = UniversalValidators.max(this.max);
    }
    ngOnChanges(changes) {
        if (changes.max && !changes.max.isFirstChange()) {
            this.validator = UniversalValidators.max(changes.max.currentValue);
            this.onChange();
        }
    }
    validate(c) {
        return this.validator(c);
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
};
tslib_1.__decorate([
    Input()
], MaxValidatorDirective.prototype, "max", void 0);
MaxValidatorDirective = MaxValidatorDirective_1 = tslib_1.__decorate([
    Directive({
        selector: "input[type=text][max][formControlName],input[type=text][max][formControl],input[type=text][max][ngModel]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(() => MaxValidatorDirective_1),
                multi: true,
            },
        ],
    })
], MaxValidatorDirective);
export { MaxValidatorDirective };
let MinValidatorDirective = MinValidatorDirective_1 = class MinValidatorDirective {
    ngOnInit() {
        this.validator = UniversalValidators.min(this.min);
    }
    ngOnChanges(changes) {
        if (changes.min && !changes.min.isFirstChange()) {
            this.validator = UniversalValidators.min(changes.min.currentValue);
            this.onChange();
        }
    }
    validate(c) {
        return this.validator(c);
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
};
tslib_1.__decorate([
    Input()
], MinValidatorDirective.prototype, "min", void 0);
MinValidatorDirective = MinValidatorDirective_1 = tslib_1.__decorate([
    Directive({
        selector: "input[type=text][min][formControlName],input[type=text][min][formControl],input[type=text][min][ngModel]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(() => MinValidatorDirective_1),
                multi: true,
            },
        ],
    })
], MinValidatorDirective);
export { MinValidatorDirective };
let MinDateValidatorDirective = MinDateValidatorDirective_1 = class MinDateValidatorDirective {
    ngOnInit() {
        this.validator = UniversalValidators.minDate(new Date(this.minDate));
    }
    ngOnChanges(changes) {
        if (changes.minDate && !changes.minDate.isFirstChange()) {
            this.validator = UniversalValidators.minDate(changes.min.currentValue);
            this.onChange();
        }
    }
    validate(c) {
        return this.validator(c);
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
};
tslib_1.__decorate([
    Input()
], MinDateValidatorDirective.prototype, "minDate", void 0);
MinDateValidatorDirective = MinDateValidatorDirective_1 = tslib_1.__decorate([
    Directive({
        selector: "input[type=text][minDate][formControlName],input[type=text][minDate][formControl],input[type=text][minDate][ngModel]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(() => MinDateValidatorDirective_1),
                multi: true,
            },
        ],
    })
], MinDateValidatorDirective);
export { MinDateValidatorDirective };
let MaxDateValidatorDirective = MaxDateValidatorDirective_1 = class MaxDateValidatorDirective {
    ngOnInit() {
        this.validator = UniversalValidators.maxDate(new Date(this.maxDate));
    }
    ngOnChanges(changes) {
        if (changes.maxDate && !changes.maxDate.isFirstChange()) {
            this.validator = UniversalValidators.maxDate(changes.min.currentValue);
            this.onChange();
        }
    }
    validate(c) {
        return this.validator(c);
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
};
tslib_1.__decorate([
    Input()
], MaxDateValidatorDirective.prototype, "maxDate", void 0);
MaxDateValidatorDirective = MaxDateValidatorDirective_1 = tslib_1.__decorate([
    Directive({
        selector: "input[type=text][maxDate][formControlName],input[type=text][maxDate][formControl],input[type=text][maxDate][ngModel]",
        providers: [
            {
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(() => MaxDateValidatorDirective_1),
                multi: true,
            },
        ],
    })
], MaxDateValidatorDirective);
export { MaxDateValidatorDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW5pdmVyc2FsLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC12YWxpZGF0b3JzLyIsInNvdXJjZXMiOlsiY29tcG9uZW50cy91bml2ZXJzYWwvdW5pdmVyc2FsLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBb0MsTUFBTSxlQUFlLENBQUM7QUFDL0YsT0FBTyxFQUFtQixhQUFhLEVBQTRDLE1BQU0sZ0JBQWdCLENBQUM7QUFFMUcsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFhN0QsSUFBYSw0QkFBNEIsb0NBQXpDLE1BQWEsNEJBQTRCO0lBR3ZDLFFBQVE7UUFDTixJQUFJLENBQUMsU0FBUyxHQUFHLG1CQUFtQixDQUFDLFlBQVksQ0FBQztJQUNwRCxDQUFDO0lBRUQsUUFBUSxDQUFDLENBQWtCO1FBQ3pCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMzQixDQUFDO0NBQ0YsQ0FBQTtBQVZZLDRCQUE0QjtJQVh4QyxTQUFTLENBQUM7UUFDVCxRQUFRLEVBQUUscUZBQXFGO1FBQy9GLFNBQVMsRUFBRTtZQUNUO2dCQUNFLE9BQU8sRUFBRSxhQUFhO2dCQUN0QiwwQ0FBMEM7Z0JBQzFDLFdBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsOEJBQTRCLENBQUM7Z0JBQzNELEtBQUssRUFBRSxJQUFJO2FBQ1o7U0FDRjtLQUNGLENBQUM7R0FDVyw0QkFBNEIsQ0FVeEM7U0FWWSw0QkFBNEI7QUF1QnpDLElBQWEsNkJBQTZCLHFDQUExQyxNQUFhLDZCQUE2QjtJQUd4QyxRQUFRO1FBQ04sSUFBSSxDQUFDLFNBQVMsR0FBRyxtQkFBbUIsQ0FBQyxhQUFhLENBQUM7SUFDckQsQ0FBQztJQUVELFFBQVEsQ0FBQyxDQUFrQjtRQUN6QixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDM0IsQ0FBQztDQUNGLENBQUE7QUFWWSw2QkFBNkI7SUFYekMsU0FBUyxDQUFDO1FBQ1QsUUFBUSxFQUFFLHdGQUF3RjtRQUNsRyxTQUFTLEVBQUU7WUFDVDtnQkFDRSxPQUFPLEVBQUUsYUFBYTtnQkFDdEIsMENBQTBDO2dCQUMxQyxXQUFXLEVBQUUsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLCtCQUE2QixDQUFDO2dCQUM1RCxLQUFLLEVBQUUsSUFBSTthQUNaO1NBQ0Y7S0FDRixDQUFDO0dBQ1csNkJBQTZCLENBVXpDO1NBVlksNkJBQTZCO0FBdUIxQyxJQUFhLDBCQUEwQixrQ0FBdkMsTUFBYSwwQkFBMEI7SUFHckMsUUFBUTtRQUNOLElBQUksQ0FBQyxTQUFTLEdBQUcsbUJBQW1CLENBQUMsUUFBUSxDQUFDO0lBQ2hELENBQUM7SUFFRCxRQUFRLENBQUMsQ0FBa0I7UUFDekIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNCLENBQUM7Q0FDRixDQUFBO0FBVlksMEJBQTBCO0lBWHRDLFNBQVMsQ0FBQztRQUNULFFBQVEsRUFBRSx5RUFBeUU7UUFDbkYsU0FBUyxFQUFFO1lBQ1Q7Z0JBQ0UsT0FBTyxFQUFFLGFBQWE7Z0JBQ3RCLDBDQUEwQztnQkFDMUMsV0FBVyxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyw0QkFBMEIsQ0FBQztnQkFDekQsS0FBSyxFQUFFLElBQUk7YUFDWjtTQUNGO0tBQ0YsQ0FBQztHQUNXLDBCQUEwQixDQVV0QztTQVZZLDBCQUEwQjtBQXVCdkMsSUFBYSwyQkFBMkIsbUNBQXhDLE1BQWEsMkJBQTJCO0lBT3RDLFFBQVE7UUFDTixJQUFJLENBQUMsU0FBUyxHQUFHLG1CQUFtQixDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUMvRSxDQUFDO0lBRUQsV0FBVyxDQUFDLE9BQXNCO1FBQ2hDLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDN0IsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUM3QixJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUM7UUFFcEIsSUFBSSxPQUFPLENBQUMsUUFBUSxFQUFFO1lBQ3BCLFFBQVEsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQztZQUN6QyxPQUFPLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7U0FDM0Q7UUFFRCxJQUFJLE9BQU8sQ0FBQyxRQUFRLEVBQUU7WUFDcEIsUUFBUSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDO1lBQ3pDLE9BQU8sR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztTQUMzRDtRQUVELElBQUksT0FBTyxFQUFFO1lBQ1gsSUFBSSxDQUFDLFNBQVMsR0FBRyxtQkFBbUIsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQ25FLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztTQUNqQjtJQUNILENBQUM7SUFFRCxRQUFRLENBQUMsQ0FBa0I7UUFDekIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRCx5QkFBeUIsQ0FBQyxFQUFjO1FBQ3RDLElBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDO0lBQ3JCLENBQUM7Q0FDRixDQUFBO0FBdENVO0lBQVIsS0FBSyxFQUFFOzZEQUFrQjtBQUNqQjtJQUFSLEtBQUssRUFBRTs2REFBa0I7QUFGZiwyQkFBMkI7SUFYdkMsU0FBUyxDQUFDO1FBQ1QsUUFBUSxFQUFFLDRFQUE0RTtRQUN0RixTQUFTLEVBQUU7WUFDVDtnQkFDRSxPQUFPLEVBQUUsYUFBYTtnQkFDdEIsMENBQTBDO2dCQUMxQyxXQUFXLEVBQUUsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLDZCQUEyQixDQUFDO2dCQUMxRCxLQUFLLEVBQUUsSUFBSTthQUNaO1NBQ0Y7S0FDRixDQUFDO0dBQ1csMkJBQTJCLENBdUN2QztTQXZDWSwyQkFBMkI7QUFvRHhDLElBQWEscUJBQXFCLDZCQUFsQyxNQUFhLHFCQUFxQjtJQU1oQyxRQUFRO1FBQ04sSUFBSSxDQUFDLFNBQVMsR0FBRyxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUFFRCxXQUFXLENBQUMsT0FBc0I7UUFDaEMsSUFBSSxPQUFPLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxhQUFhLEVBQUUsRUFBRTtZQUMvQyxJQUFJLENBQUMsU0FBUyxHQUFHLG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQ25FLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztTQUNqQjtJQUNILENBQUM7SUFFRCxRQUFRLENBQUMsQ0FBa0I7UUFDekIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRCx5QkFBeUIsQ0FBQyxFQUFjO1FBQ3RDLElBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDO0lBQ3JCLENBQUM7Q0FDRixDQUFBO0FBdkJVO0lBQVIsS0FBSyxFQUFFO2tEQUFhO0FBRFYscUJBQXFCO0lBWGpDLFNBQVMsQ0FBQztRQUNULFFBQVEsRUFBRSwwR0FBMEc7UUFDcEgsU0FBUyxFQUFFO1lBQ1Q7Z0JBQ0UsT0FBTyxFQUFFLGFBQWE7Z0JBQ3RCLDBDQUEwQztnQkFDMUMsV0FBVyxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyx1QkFBcUIsQ0FBQztnQkFDcEQsS0FBSyxFQUFFLElBQUk7YUFDWjtTQUNGO0tBQ0YsQ0FBQztHQUNXLHFCQUFxQixDQXdCakM7U0F4QlkscUJBQXFCO0FBcUNsQyxJQUFhLHFCQUFxQiw2QkFBbEMsTUFBYSxxQkFBcUI7SUFNaEMsUUFBUTtRQUNOLElBQUksQ0FBQyxTQUFTLEdBQUcsbUJBQW1CLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBRUQsV0FBVyxDQUFDLE9BQXNCO1FBQ2hDLElBQUksT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFLEVBQUU7WUFDL0MsSUFBSSxDQUFDLFNBQVMsR0FBRyxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUNuRSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7U0FDakI7SUFDSCxDQUFDO0lBRUQsUUFBUSxDQUFDLENBQWtCO1FBQ3pCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRUQseUJBQXlCLENBQUMsRUFBYztRQUN0QyxJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztJQUNyQixDQUFDO0NBQ0YsQ0FBQTtBQXZCVTtJQUFSLEtBQUssRUFBRTtrREFBYTtBQURWLHFCQUFxQjtJQVhqQyxTQUFTLENBQUM7UUFDVCxRQUFRLEVBQUUsMEdBQTBHO1FBQ3BILFNBQVMsRUFBRTtZQUNUO2dCQUNFLE9BQU8sRUFBRSxhQUFhO2dCQUN0QiwwQ0FBMEM7Z0JBQzFDLFdBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsdUJBQXFCLENBQUM7Z0JBQ3BELEtBQUssRUFBRSxJQUFJO2FBQ1o7U0FDRjtLQUNGLENBQUM7R0FDVyxxQkFBcUIsQ0F3QmpDO1NBeEJZLHFCQUFxQjtBQXFDbEMsSUFBYSx5QkFBeUIsaUNBQXRDLE1BQWEseUJBQXlCO0lBTXBDLFFBQVE7UUFDTixJQUFJLENBQUMsU0FBUyxHQUFHLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUN2RSxDQUFDO0lBRUQsV0FBVyxDQUFDLE9BQXNCO1FBQ2hDLElBQUksT0FBTyxDQUFDLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsYUFBYSxFQUFFLEVBQUU7WUFDdkQsSUFBSSxDQUFDLFNBQVMsR0FBRyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUN2RSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7U0FDakI7SUFDSCxDQUFDO0lBRUQsUUFBUSxDQUFDLENBQWtCO1FBQ3pCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRUQseUJBQXlCLENBQUMsRUFBYztRQUN0QyxJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztJQUNyQixDQUFDO0NBQ0YsQ0FBQTtBQXZCVTtJQUFSLEtBQUssRUFBRTswREFBaUI7QUFEZCx5QkFBeUI7SUFYckMsU0FBUyxDQUFDO1FBQ1QsUUFBUSxFQUFFLHNIQUFzSDtRQUNoSSxTQUFTLEVBQUU7WUFDVDtnQkFDRSxPQUFPLEVBQUUsYUFBYTtnQkFDdEIsMENBQTBDO2dCQUMxQyxXQUFXLEVBQUUsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLDJCQUF5QixDQUFDO2dCQUN4RCxLQUFLLEVBQUUsSUFBSTthQUNaO1NBQ0Y7S0FDRixDQUFDO0dBQ1cseUJBQXlCLENBd0JyQztTQXhCWSx5QkFBeUI7QUFxQ3RDLElBQWEseUJBQXlCLGlDQUF0QyxNQUFhLHlCQUF5QjtJQU1wQyxRQUFRO1FBQ04sSUFBSSxDQUFDLFNBQVMsR0FBRyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDdkUsQ0FBQztJQUVELFdBQVcsQ0FBQyxPQUFzQjtRQUNoQyxJQUFJLE9BQU8sQ0FBQyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFBRSxFQUFFO1lBQ3ZELElBQUksQ0FBQyxTQUFTLEdBQUcsbUJBQW1CLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDdkUsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1NBQ2pCO0lBQ0gsQ0FBQztJQUVELFFBQVEsQ0FBQyxDQUFrQjtRQUN6QixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVELHlCQUF5QixDQUFDLEVBQWM7UUFDdEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7SUFDckIsQ0FBQztDQUNGLENBQUE7QUF2QlU7SUFBUixLQUFLLEVBQUU7MERBQWlCO0FBRGQseUJBQXlCO0lBWHJDLFNBQVMsQ0FBQztRQUNULFFBQVEsRUFBRSxzSEFBc0g7UUFDaEksU0FBUyxFQUFFO1lBQ1Q7Z0JBQ0UsT0FBTyxFQUFFLGFBQWE7Z0JBQ3RCLDBDQUEwQztnQkFDMUMsV0FBVyxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQywyQkFBeUIsQ0FBQztnQkFDeEQsS0FBSyxFQUFFLElBQUk7YUFDWjtTQUNGO0tBQ0YsQ0FBQztHQUNXLHlCQUF5QixDQXdCckM7U0F4QlkseUJBQXlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBmb3J3YXJkUmVmLCBJbnB1dCwgT25Jbml0LCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBOR19WQUxJREFUT1JTLCBWYWxpZGF0b3IsIFZhbGlkYXRvckZuLCBWYWxpZGF0aW9uRXJyb3JzIH0gZnJvbSBcIkBhbmd1bGFyL2Zvcm1zXCI7XG5cbmltcG9ydCB7IFVuaXZlcnNhbFZhbGlkYXRvcnMgfSBmcm9tIFwiLi91bml2ZXJzYWwtdmFsaWRhdG9yc1wiO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6IFwiW25vV2hpdGVzcGFjZV1bZm9ybUNvbnRyb2xOYW1lXSxbbm9XaGl0ZXNwYWNlXVtmb3JtQ29udHJvbF0sW25vV2hpdGVzcGFjZV1bbmdNb2RlbF1cIixcbiAgcHJvdmlkZXJzOiBbXG4gICAge1xuICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gV2hpdGVTcGFjZVZhbGlkYXRvckRpcmVjdGl2ZSksXG4gICAgICBtdWx0aTogdHJ1ZSxcbiAgICB9LFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBXaGl0ZVNwYWNlVmFsaWRhdG9yRGlyZWN0aXZlIGltcGxlbWVudHMgVmFsaWRhdG9yLCBPbkluaXQge1xuICBwcml2YXRlIHZhbGlkYXRvcjogVmFsaWRhdG9yRm47XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy52YWxpZGF0b3IgPSBVbml2ZXJzYWxWYWxpZGF0b3JzLm5vV2hpdGVzcGFjZTtcbiAgfVxuXG4gIHZhbGlkYXRlKGM6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRvcihjKTtcbiAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6IFwiW25vRW1wdHlTdHJpbmddW2Zvcm1Db250cm9sTmFtZV0sW25vRW1wdHlTdHJpbmddW2Zvcm1Db250cm9sXSxbbm9FbXB0eVN0cmluZ11bbmdNb2RlbF1cIixcbiAgcHJvdmlkZXJzOiBbXG4gICAge1xuICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRW1wdHlTdHJpbmdWYWxpZGF0b3JEaXJlY3RpdmUpLFxuICAgICAgbXVsdGk6IHRydWUsXG4gICAgfSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgRW1wdHlTdHJpbmdWYWxpZGF0b3JEaXJlY3RpdmUgaW1wbGVtZW50cyBWYWxpZGF0b3IsIE9uSW5pdCB7XG4gIHByaXZhdGUgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnZhbGlkYXRvciA9IFVuaXZlcnNhbFZhbGlkYXRvcnMubm9FbXB0eVN0cmluZztcbiAgfVxuXG4gIHZhbGlkYXRlKGM6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRvcihjKTtcbiAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6IFwiW2lzTnVtYmVyXVtmb3JtQ29udHJvbE5hbWVdLFtpc051bWJlcl1bZm9ybUNvbnRyb2xdLFtpc051bWJlcl1bbmdNb2RlbF1cIixcbiAgcHJvdmlkZXJzOiBbXG4gICAge1xuICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gSXNOdW1iZXJWYWxpZGF0b3JEaXJlY3RpdmUpLFxuICAgICAgbXVsdGk6IHRydWUsXG4gICAgfSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgSXNOdW1iZXJWYWxpZGF0b3JEaXJlY3RpdmUgaW1wbGVtZW50cyBWYWxpZGF0b3IsIE9uSW5pdCB7XG4gIHByaXZhdGUgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnZhbGlkYXRvciA9IFVuaXZlcnNhbFZhbGlkYXRvcnMuaXNOdW1iZXI7XG4gIH1cblxuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0b3IoYyk7XG4gIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiBcIltpc0luUmFuZ2VdW2Zvcm1Db250cm9sTmFtZV0sW2lzSW5SYW5nZV1bZm9ybUNvbnRyb2xdLFtpc0luUmFuZ2VdW25nTW9kZWxdXCIsXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IElzSW5SYW5nZVZhbGlkYXRvckRpcmVjdGl2ZSksXG4gICAgICBtdWx0aTogdHJ1ZSxcbiAgICB9LFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBJc0luUmFuZ2VWYWxpZGF0b3JEaXJlY3RpdmUgaW1wbGVtZW50cyBWYWxpZGF0b3IsIE9uSW5pdCwgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgbWluVmFsdWU6IG51bWJlcjtcbiAgQElucHV0KCkgbWF4VmFsdWU6IG51bWJlcjtcblxuICBwcml2YXRlIHZhbGlkYXRvcjogVmFsaWRhdG9yRm47XG4gIHByaXZhdGUgb25DaGFuZ2U6ICgpID0+IHZvaWQ7XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy52YWxpZGF0b3IgPSBVbml2ZXJzYWxWYWxpZGF0b3JzLmlzSW5SYW5nZSh0aGlzLm1pblZhbHVlLCB0aGlzLm1heFZhbHVlKTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBsZXQgbWluVmFsdWUgPSB0aGlzLm1pblZhbHVlO1xuICAgIGxldCBtYXhWYWx1ZSA9IHRoaXMubWF4VmFsdWU7XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcblxuICAgIGlmIChjaGFuZ2VzLm1pblZhbHVlKSB7XG4gICAgICBtaW5WYWx1ZSA9IGNoYW5nZXMubWluVmFsdWUuY3VycmVudFZhbHVlO1xuICAgICAgY2hhbmdlZCA9IGNoYW5nZXMubWluVmFsdWUuaXNGaXJzdENoYW5nZSgpID8gZmFsc2UgOiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2VzLm1heFZhbHVlKSB7XG4gICAgICBtYXhWYWx1ZSA9IGNoYW5nZXMubWF4VmFsdWUuY3VycmVudFZhbHVlO1xuICAgICAgY2hhbmdlZCA9IGNoYW5nZXMubWF4VmFsdWUuaXNGaXJzdENoYW5nZSgpID8gZmFsc2UgOiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLnZhbGlkYXRvciA9IFVuaXZlcnNhbFZhbGlkYXRvcnMuaXNJblJhbmdlKG1pblZhbHVlLCBtYXhWYWx1ZSk7XG4gICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUoYzogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yKGMpO1xuICB9XG5cbiAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6IFwiaW5wdXRbdHlwZT10ZXh0XVttYXhdW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT10ZXh0XVttYXhdW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPXRleHRdW21heF1bbmdNb2RlbF1cIixcbiAgcHJvdmlkZXJzOiBbXG4gICAge1xuICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTWF4VmFsaWRhdG9yRGlyZWN0aXZlKSxcbiAgICAgIG11bHRpOiB0cnVlLFxuICAgIH0sXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIE1heFZhbGlkYXRvckRpcmVjdGl2ZSBpbXBsZW1lbnRzIFZhbGlkYXRvciwgT25Jbml0LCBPbkNoYW5nZXMge1xuICBASW5wdXQoKSBtYXg6IG51bWJlcjtcblxuICBwcml2YXRlIHZhbGlkYXRvcjogVmFsaWRhdG9yRm47XG4gIHByaXZhdGUgb25DaGFuZ2U6ICgpID0+IHZvaWQ7XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy52YWxpZGF0b3IgPSBVbml2ZXJzYWxWYWxpZGF0b3JzLm1heCh0aGlzLm1heCk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgaWYgKGNoYW5nZXMubWF4ICYmICFjaGFuZ2VzLm1heC5pc0ZpcnN0Q2hhbmdlKCkpIHtcbiAgICAgIHRoaXMudmFsaWRhdG9yID0gVW5pdmVyc2FsVmFsaWRhdG9ycy5tYXgoY2hhbmdlcy5tYXguY3VycmVudFZhbHVlKTtcbiAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0b3IoYyk7XG4gIH1cblxuICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICB9XG59XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogXCJpbnB1dFt0eXBlPXRleHRdW21pbl1bZm9ybUNvbnRyb2xOYW1lXSxpbnB1dFt0eXBlPXRleHRdW21pbl1bZm9ybUNvbnRyb2xdLGlucHV0W3R5cGU9dGV4dF1bbWluXVtuZ01vZGVsXVwiLFxuICBwcm92aWRlcnM6IFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNaW5WYWxpZGF0b3JEaXJlY3RpdmUpLFxuICAgICAgbXVsdGk6IHRydWUsXG4gICAgfSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgTWluVmFsaWRhdG9yRGlyZWN0aXZlIGltcGxlbWVudHMgVmFsaWRhdG9yLCBPbkluaXQsIE9uQ2hhbmdlcyB7XG4gIEBJbnB1dCgpIG1pbjogbnVtYmVyO1xuXG4gIHByaXZhdGUgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcbiAgcHJpdmF0ZSBvbkNoYW5nZTogKCkgPT4gdm9pZDtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnZhbGlkYXRvciA9IFVuaXZlcnNhbFZhbGlkYXRvcnMubWluKHRoaXMubWluKTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBpZiAoY2hhbmdlcy5taW4gJiYgIWNoYW5nZXMubWluLmlzRmlyc3RDaGFuZ2UoKSkge1xuICAgICAgdGhpcy52YWxpZGF0b3IgPSBVbml2ZXJzYWxWYWxpZGF0b3JzLm1pbihjaGFuZ2VzLm1pbi5jdXJyZW50VmFsdWUpO1xuICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlKGM6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRvcihjKTtcbiAgfVxuXG4gIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiBcImlucHV0W3R5cGU9dGV4dF1bbWluRGF0ZV1bZm9ybUNvbnRyb2xOYW1lXSxpbnB1dFt0eXBlPXRleHRdW21pbkRhdGVdW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPXRleHRdW21pbkRhdGVdW25nTW9kZWxdXCIsXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZm9yd2FyZC1yZWZcbiAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE1pbkRhdGVWYWxpZGF0b3JEaXJlY3RpdmUpLFxuICAgICAgbXVsdGk6IHRydWUsXG4gICAgfSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgTWluRGF0ZVZhbGlkYXRvckRpcmVjdGl2ZSBpbXBsZW1lbnRzIFZhbGlkYXRvciwgT25Jbml0LCBPbkNoYW5nZXMge1xuICBASW5wdXQoKSBtaW5EYXRlOiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSB2YWxpZGF0b3I6IFZhbGlkYXRvckZuO1xuICBwcml2YXRlIG9uQ2hhbmdlOiAoKSA9PiB2b2lkO1xuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMudmFsaWRhdG9yID0gVW5pdmVyc2FsVmFsaWRhdG9ycy5taW5EYXRlKG5ldyBEYXRlKHRoaXMubWluRGF0ZSkpO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIGlmIChjaGFuZ2VzLm1pbkRhdGUgJiYgIWNoYW5nZXMubWluRGF0ZS5pc0ZpcnN0Q2hhbmdlKCkpIHtcbiAgICAgIHRoaXMudmFsaWRhdG9yID0gVW5pdmVyc2FsVmFsaWRhdG9ycy5taW5EYXRlKGNoYW5nZXMubWluLmN1cnJlbnRWYWx1ZSk7XG4gICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUoYzogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yKGMpO1xuICB9XG5cbiAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6IFwiaW5wdXRbdHlwZT10ZXh0XVttYXhEYXRlXVtmb3JtQ29udHJvbE5hbWVdLGlucHV0W3R5cGU9dGV4dF1bbWF4RGF0ZV1bZm9ybUNvbnRyb2xdLGlucHV0W3R5cGU9dGV4dF1bbWF4RGF0ZV1bbmdNb2RlbF1cIixcbiAgcHJvdmlkZXJzOiBbXG4gICAge1xuICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTWF4RGF0ZVZhbGlkYXRvckRpcmVjdGl2ZSksXG4gICAgICBtdWx0aTogdHJ1ZSxcbiAgICB9LFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBNYXhEYXRlVmFsaWRhdG9yRGlyZWN0aXZlIGltcGxlbWVudHMgVmFsaWRhdG9yLCBPbkluaXQsIE9uQ2hhbmdlcyB7XG4gIEBJbnB1dCgpIG1heERhdGU6IHN0cmluZztcblxuICBwcml2YXRlIHZhbGlkYXRvcjogVmFsaWRhdG9yRm47XG4gIHByaXZhdGUgb25DaGFuZ2U6ICgpID0+IHZvaWQ7XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy52YWxpZGF0b3IgPSBVbml2ZXJzYWxWYWxpZGF0b3JzLm1heERhdGUobmV3IERhdGUodGhpcy5tYXhEYXRlKSk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgaWYgKGNoYW5nZXMubWF4RGF0ZSAmJiAhY2hhbmdlcy5tYXhEYXRlLmlzRmlyc3RDaGFuZ2UoKSkge1xuICAgICAgdGhpcy52YWxpZGF0b3IgPSBVbml2ZXJzYWxWYWxpZGF0b3JzLm1heERhdGUoY2hhbmdlcy5taW4uY3VycmVudFZhbHVlKTtcbiAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0b3IoYyk7XG4gIH1cblxuICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICB9XG59Il19